---
title: Control Surfaces
description: CLI vs GUI responsibilities for the Virtualia workspace
---

# Control Surfaces Overview

Virtualia distinguishes between **agents** (LLMs, scripts, CI) and **humans** (operators, authors). Agents interact through JSON-first CLIs; humans use a dedicated GUI/REPL (the forthcoming Control Pear) that shells those commands and exposes toggles.

## Swarm-only replication contract

- Each long-lived process (Deck, relay, RTS, Economy, Toolbelt) owns exactly **one corestore** and **one Hyperswarm instance**. When another process needs those feeds, it replicates them over Hyperswarm (NeonURI/Protomux) using shared keys, never by reusing the owner’s filesystem path.
- Key/URI sharing may happen via local IPC or HTTP (e.g., Deck exposing `mesh.topicsDetailed`), but the data itself must travel across the swarm. This keeps agent/human tooling honest about replication cost and topology.
- Local GUI endpoints (Deck dash, relay `/resources`, RTS HUD sockets) are presentation-only; every metric they display—neighbor graphs, bandwidth/SOD pressure, Neon bundle health—already exists inside the consolidated `/api/status` payload fueled by swarm replication.

## Personas

- **Agents**  
  - Consume CLI commands with `--json` output.  
  - Trigger smokes, bundle builds, and deployments automatically.  
  - Expect deterministic exits and no interactive prompts.

- **Humans**  
  - Launch the Control Pear app for dashboards, toggles, and advanced views.  
  - Can run the same CLI commands from a terminal if needed.  
  - Configure advanced options via the GUI, while defaults remain zero-config.

## Status JSON Contracts

Each repo exposes a status command returning machine-readable summaries:

| Concern | Command | JSON Payload Highlights |
|---------|---------|-------------------------|
| Economy | `meshctl economy describe --json` (alias: `npm run interop:status --workspace economy`) | Tick, ledger totals, validator quorum, checkpoint info |
| Missions | `npm run status --workspace HyperQuill` | Last bundle hash, missing unlocks, validation errors |
| RTS | `npm run interop:status:rts --workspace rts -- --refresh` | Runs the headless replay smoke, writes `dist/interop/rts-status.json`, and reports drift/unlock warnings |
| Website | `npm run interop:status:web --workspace website` | Published bundle hash, Hyperdrive mirror lag, resource budgets, requestBodySupport flag |
| Toolbelt | `meshctl interop status` | Aggregated view combining the commands above |

The root-level `scripts/control/status.mjs` (see below) will call these commands and emit a single consolidated JSON document for agents and for the Control Pear.

## Environment & Configuration

- All repos rely on Toolbelt’s env loader (`toolbelt/src/lib/envLoader.js`) to stack root `.env`, `.env.local`, and per-tool overrides.  
- The Control Pear GUI will surface these variables with an “Advanced” toggle; agents set them via `meshctl config set`.
- Each GUI surface publishes a `resources` block (CPU/RAM/network/cache budgets) via its status command; see [`docs/interop/resources.md`](interop/resources.md) for the shared schema.

## Deployment Manifest

- `dist/interop/manifest.json` (generated by `node scripts/control/generate-manifest.mjs`) captures the artifacts required to deploy the swarm: economy bundle (with manifest entry + checksum), RTS checkpoint, mission bundle, website assets, Hyperswarm topics, and Hyperdrive mirrors.  
- `meshctl swarm deploy` will consume this manifest; the GUI will present the same data before pushing to remote nodes.

## Root Scripts

| Script | Purpose |
|--------|---------|
| `npm run status` | Calls `scripts/control/status.mjs`, emitting the consolidated JSON snapshot (economy bundle, mission smoke, RTS smoke, relay status). |
| `npm run smoke` | Runs economy, HyperQuill, RTS, and Toolbelt smokes in sequence via `scripts/control/workspace-smoke.mjs`; accepts `--json`, `--only`, and `--skip` for CI pipelines. |
| `npm run harness` | Invokes `scripts/control/workspace-harness.mjs` to spin up Toolbelt status services + the economy coordinator, then run the RTS headless client and HyperQuill mock author in one workflow (see `docs/interop/runbooks/workspace-harness.md`). |
| `npm run dev:swarm` | (Planned) Starts economy coordinator, RTS observer, HyperQuill watch, website viewer with default presets. |

These scripts ensure the CLI acts as the backbone for both automated agents and the human-facing Control Pear.

## Deploy Surfaces

- `meshctl deploy prep` bundles repo artifacts (economy fragments, HyperQuill missions, RTS deploy manifests, website relay manifest) using the repo-provided `deploy:prep` scripts defined in Toolbelt’s layered config.
- `meshctl deploy status` now reads those fragments and reports readiness (bundle IDs, checkpoint ticks, relay write-capability) so the Control Pear can gate GUI deploy toggles on real artifacts.

## HyperQuill Workspace Notes

- The refreshed HyperQuill shell is detailed in [`docs/projects/HyperQuill/workspace.md`](projects/HyperQuill/workspace.md). It covers the drive manager bridge, mission packaging toggles, and how entity metadata flows into the Toolbelt/RTS contracts.
- Manage/Attach actions in the Media panel now call the same `driveManager`/`driveExplorer` services as the legacy drive browser, so Control Pear can either reuse the lightweight overlay or continue embedding the full browser for advanced flows. Headless agents can call `npm run drives:manage -- --list|--attach|--detach` to perform the same actions without a GUI. Use `npm run entities:export` to snapshot entity descriptors (type/relationship/tags) straight from Keybook and feed them into mission bundles/Building Graph metadata.
- The Entities modal persists the new type/relationship/tag metadata inside Keybook. Control Pear should mirror those inputs when authoring missions so RTS/Economy bundles remain self-describing.
